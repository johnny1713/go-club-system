<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åœæ£‹ç¤¾æ¯”è³½å ±åèˆ‡å°æˆ°ç³»çµ±</title>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-database-compat.js"></script>

    <style>
        :root {
            --primary: #2c3e50;
            --accent: #d35400;
            --bg: #fdfbf7; /* æ£‹ç›¤æœ¨é ­è‰²èª¿ */
            --board-color: #e6b35c;
        }
        body { font-family: "Microsoft JhengHei", sans-serif; background-color: var(--bg); margin: 0; padding: 20px; color: #333; }
        
        .container { max-width: 1200px; margin: 0 auto; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        
        h1 { text-align: center; color: var(--primary); cursor: pointer; user-select: none; }
        h2 { border-bottom: 2px solid var(--board-color); padding-bottom: 10px; }

        /* Tabs */
        .tabs { display: flex; gap: 10px; margin-bottom: 20px; border-bottom: 1px solid #ddd; }
        .tab { padding: 10px 20px; cursor: pointer; background: #eee; border-radius: 5px 5px 0 0; }
        .tab.active { background: var(--primary); color: white; font-weight: bold; }
        .tab-content { display: none; }
        .tab-content.active { display: block; }

        /* Form & List */
        .form-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 5px; font-weight: bold; }
        input, select { width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; }
        button { background: var(--primary); color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer; font-size: 16px; }
        button:hover { opacity: 0.9; }
        button.danger { background: #c0392b; }
        button.admin-btn { background: var(--accent); display: none; margin-left: 10px; }

        table { width: 100%; border-collapse: collapse; margin-top: 20px; }
        th, td { border: 1px solid #ddd; padding: 12px; text-align: left; }
        th { background-color: var(--primary); color: white; }
        tr:nth-child(even) { background-color: #f2f2f2; }

        /* Admin Mode Styling */
        body.is-admin .admin-btn { display: inline-block; }
        body.is-admin .admin-action { display: table-cell; }
        .admin-action { display: none; }

        /* Bracket Styles */
        .bracket-container { display: flex; overflow-x: auto; padding: 20px 0; min-height: 400px; }
        .round { display: flex; flex-direction: column; justify-content: space-around; min-width: 200px; margin-right: 40px; }
        .match { background: #fff; border: 1px solid #ccc; margin: 10px 0; padding: 10px; border-radius: 4px; position: relative; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        .match:hover { border-color: var(--accent); }
        
        .player { padding: 5px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; }
        .player:hover { background-color: #f0f0f0; }
        .player.winner { font-weight: bold; color: green; }
        .player.loser { color: #999; text-decoration: line-through; }
        .player input { width: 80%; padding: 2px; font-size: 12px; }

        .score { font-size: 0.8em; color: #666; }
        
        /* å† è»æ¨™ç¤º */
        .champion-box { text-align: center; border: 2px solid gold; background: #fffdf0; margin-top: 20px; padding: 20px; display: none; }
        
        /* å­£æ®¿è»å€å¡Š */
        .third-place-container { margin-top: 30px; border-top: 2px dashed #ccc; padding-top: 20px; }
        .third-place-title { font-weight: bold; color: var(--accent); margin-bottom: 10px; }

        /* Connecting Lines (Simplified) */
        .round:not(:first-child) .match::before {
            content: ""; position: absolute; left: -20px; top: 50%; width: 20px; height: 1px; background: #ccc;
        }

        .edit-input { width: 100px; padding: 2px; }
    </style>
</head>
<body>

<div class="container">
    <h1 id="appTitle" title="é»æ“Š5æ¬¡é–‹å•Ÿç®¡ç†å“¡æ¨¡å¼">åœæ£‹ç¤¾å…§éƒ¨æ¯”è³½ç³»çµ±</h1>
    <div id="adminStatus" style="text-align:center; color: red; display:none;">(ç®¡ç†å“¡æ¨¡å¼å·²å•Ÿç”¨)</div>

    <div class="tabs">
        <div class="tab active" onclick="switchTab('register')">å ±åé é¢</div>
        <div class="tab" onclick="switchTab('list')">å ±ååå–®</div>
        <div class="tab" onclick="switchTab('bracket-beginner')">å…¥é–€çµ„å°æˆ°è¡¨</div>
        <div class="tab" onclick="switchTab('bracket-advanced')">é€²éšçµ„å°æˆ°è¡¨</div>
    </div>

    <div id="register" class="tab-content active">
        <h2>é¸æ‰‹å ±å</h2>
        <div class="form-group">
            <label>å§“å</label>
            <input type="text" id="regName" placeholder="è«‹è¼¸å…¥å§“å">
        </div>
        <div class="form-group">
            <label>å·¥è™Ÿ</label>
            <input type="text" id="regEmpId" placeholder="è«‹è¼¸å…¥å·¥è™Ÿ">
        </div>
        <div class="form-group">
            <label>çµ„åˆ¥</label>
            <select id="regCategory">
                <option value="beginner">å…¥é–€çµ„</option>
                <option value="advanced">é€²éšçµ„</option>
            </select>
        </div>
        <button onclick="submitRegistration()">æäº¤å ±å</button>
    </div>

    <div id="list" class="tab-content">
        <h2>å·²å ±ååå–®</h2>
        <table>
            <thead>
                <tr>
                    <th>å ±åæ™‚é–“</th>
                    <th>çµ„åˆ¥</th>
                    <th>å§“å</th>
                    <th>å·¥è™Ÿ</th>
                    <th class="admin-action">ç®¡ç†æ“ä½œ</th>
                </tr>
            </thead>
            <tbody id="registrantsTable">
                </tbody>
        </table>
    </div>

    <div id="bracket-beginner" class="tab-content">
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <h2>å…¥é–€çµ„ å°æˆ°è¡¨</h2>
            <button class="admin-btn" onclick="generateBracket('beginner')">é‡æ–°ç”¢ç”Ÿå°æˆ°è¡¨ (æ¸…é™¤èˆŠç´€éŒ„)</button>
        </div>
        <div id="beginner-bracket-area" class="bracket-container"></div>
        <div id="beginner-3rd-place" class="third-place-container" style="display:none;">
            <div class="third-place-title">å­£æ®¿è»è³½</div>
            <div id="beginner-3rd-match"></div>
        </div>
        <div id="beginner-champion" class="champion-box"></div>
    </div>

    <div id="bracket-advanced" class="tab-content">
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <h2>é€²éšçµ„ å°æˆ°è¡¨</h2>
            <button class="admin-btn" onclick="generateBracket('advanced')">é‡æ–°ç”¢ç”Ÿå°æˆ°è¡¨ (æ¸…é™¤èˆŠç´€éŒ„)</button>
        </div>
        <div id="advanced-bracket-area" class="bracket-container"></div>
        <div id="advanced-3rd-place" class="third-place-container" style="display:none;">
            <div class="third-place-title">å­£æ®¿è»è³½</div>
            <div id="advanced-3rd-match"></div>
        </div>
        <div id="advanced-champion" class="champion-box"></div>
    </div>
</div>

<script>
    // 12. Firebase Configuration
    const firebaseConfig = {
        apiKey: "AIzaSyDNmDH2jTCu9miZtzTM73H1gLYJ3EOazsQ",
        authDomain: "go-club-818e2.firebaseapp.com",
        databaseURL: "https://go-club-818e2-default-rtdb.firebaseio.com",
        projectId: "go-club-818e2",
        storageBucket: "go-club-818e2.firebasestorage.app",
        messagingSenderId: "818869551072",
        appId: "1:818869551072:web:8408991a2dedd1f9e1b585",
        measurementId: "G-3S2G8R5QJD"
    };

    // Initialize Firebase
    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();

    // --- Admin Logic (Backdoor) ---
    let clickCount = 0;
    let isAdmin = false;
    const adminPassword = "admin"; // ç°¡å–®å¯†ç¢¼ï¼Œå¯è‡ªè¡Œä¿®æ”¹

    document.getElementById('appTitle').addEventListener('click', () => {
        clickCount++;
        if (clickCount === 5) {
            const pwd = prompt("è«‹è¼¸å…¥ç®¡ç†å“¡å¯†ç¢¼ï¼š");
            if (pwd === adminPassword) {
                isAdmin = true;
                document.body.classList.add('is-admin');
                document.getElementById('adminStatus').style.display = 'block';
                alert("ç®¡ç†å“¡æ¨¡å¼å·²é–‹å•Ÿ");
                renderList(); // Re-render list to show edit buttons
            }
            clickCount = 0;
        }
    });

    // --- Tab Switching ---
    function switchTab(tabId) {
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
        
        // Find the tab element based on the onclick attribute roughly or index
        const tabs = ['register', 'list', 'bracket-beginner', 'bracket-advanced'];
        const index = tabs.indexOf(tabId);
        document.querySelectorAll('.tab')[index].classList.add('active');
        document.getElementById(tabId).classList.add('active');
    }

    // --- Registration Logic ---
    function submitRegistration() {
        const name = document.getElementById('regName').value.trim();
        const empId = document.getElementById('regEmpId').value.trim();
        const category = document.getElementById('regCategory').value;

        if (!name || !empId) {
            alert("è«‹å¡«å¯«å®Œæ•´è³‡è¨Š");
            return;
        }

        const newUserRef = db.ref('users').push();
        newUserRef.set({
            name: name,
            empId: empId,
            category: category,
            timestamp: new Date().toISOString()
        }).then(() => {
            alert("å ±åæˆåŠŸï¼");
            document.getElementById('regName').value = '';
            document.getElementById('regEmpId').value = '';
            switchTab('list');
        });
    }

    // --- List Logic ---
    let allUsers = [];

    db.ref('users').on('value', (snapshot) => {
        const data = snapshot.val();
        allUsers = [];
        if (data) {
            Object.keys(data).forEach(key => {
                allUsers.push({ id: key, ...data[key] });
            });
        }
        renderList();
    });

    function renderList() {
        const tbody = document.getElementById('registrantsTable');
        tbody.innerHTML = '';
        
        // Sort by timestamp desc
        allUsers.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

        allUsers.forEach(user => {
            const dateStr = new Date(user.timestamp).toLocaleString('zh-TW');
            const catStr = user.category === 'beginner' ? 'å…¥é–€' : 'é€²éš';
            
            let row = `<tr>
                <td>${dateStr}</td>
                <td>${catStr}</td>
                <td>${isAdmin ? `<input class='edit-input' value='${user.name}' onchange='updateUser("${user.id}", "name", this.value)'>` : user.name}</td>
                <td>${isAdmin ? `<input class='edit-input' value='${user.empId}' onchange='updateUser("${user.id}", "empId", this.value)'>` : user.empId}</td>
                <td class="admin-action">
                    <button class="danger" onclick="deleteUser('${user.id}')">åˆªé™¤</button>
                </td>
            </tr>`;
            tbody.innerHTML += row;
        });
    }

    function updateUser(id, field, value) {
        db.ref('users/' + id).update({ [field]: value });
    }

    function deleteUser(id) {
        if (confirm("ç¢ºå®šè¦åˆªé™¤é€™ä½å ±åè€…å—ï¼Ÿ")) {
            db.ref('users/' + id).remove();
        }
    }

    // --- Bracket Logic ---

    // Generate Bracket Structure
    function generateBracket(category) {
        if (!confirm("ç¢ºå®šè¦é‡æ–°ç”¢ç”Ÿå°æˆ°è¡¨å—ï¼Ÿé€™å°‡æ¸…é™¤ç›®å‰çš„æ¯”è³½é€²åº¦ï¼")) return;

        // Filter users for this category
        const participants = allUsers.filter(u => u.category === category).map(u => ({ name: u.name, id: u.id }));
        
        if (participants.length < 2) {
            alert("äººæ•¸ä¸è¶³ï¼Œç„¡æ³•ç”¢ç”Ÿå°æˆ°è¡¨");
            return;
        }

        // Shuffle
        for (let i = participants.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [participants[i], participants[j]] = [participants[j], participants[i]];
        }

        // Calculate size (power of 2)
        let size = 1;
        while (size < participants.length) size *= 2;

        // Fill with Byes
        const bracket = [];
        for (let i = 0; i < size; i++) {
            if (i < participants.length) {
                bracket.push({ name: participants[i].name, id: participants[i].id });
            } else {
                bracket.push({ name: "è¼ªç©º", id: "BYE" });
            }
        }

        // Create Matches Structure
        // We will store rounds. Round 0 is the first round.
        // Round 0 has size/2 matches. Round 1 has size/4 matches...
        
        const rounds = [];
        let currentRoundPlayers = bracket.map(p => ({...p})); // Clone

        let roundCount = Math.log2(size);
        
        for (let r = 0; r < roundCount; r++) {
            let matches = [];
            let numMatches = currentRoundPlayers.length / 2;
            
            for (let m = 0; m < numMatches; m++) {
                let p1 = currentRoundPlayers[m * 2];
                let p2 = currentRoundPlayers[m * 2 + 1];
                
                let match = {
                    p1: p1,
                    p2: p2,
                    winner: null // will be id
                };

                // Auto advance if BYE
                if (p1.id === 'BYE') match.winner = p2.id;
                else if (p2.id === 'BYE') match.winner = p1.id;

                matches.push(match);
            }
            
            rounds.push(matches);
            
            // Prepare next round placeholder
            currentRoundPlayers = matches.map(() => ({ name: "TBD", id: null }));
        }

        // Save to Firebase
        // Clear old data first to prevent issues
        db.ref(`tournament/${category}`).set({
            rounds: rounds,
            thirdPlace: { p1: null, p2: null, winner: null }, // Initialize 3rd place match
            timestamp: Date.now()
        });
    }

    // Listener for Bracket Rendering
    ['beginner', 'advanced'].forEach(cat => {
        db.ref(`tournament/${cat}`).on('value', snapshot => {
            const data = snapshot.val();
            if (data) {
                renderBracketUI(cat, data.rounds, data.thirdPlace);
            } else {
                document.getElementById(`${cat}-bracket-area`).innerHTML = '<p style="padding:20px; color:#666;">å°šæœªç”¢ç”Ÿå°æˆ°è¡¨</p>';
                document.getElementById(`${cat}-3rd-place`).style.display = 'none';
                document.getElementById(`${cat}-champion`).style.display = 'none';
            }
        });
    });

    function renderBracketUI(category, rounds, thirdPlaceData) {
        const container = document.getElementById(`${category}-bracket-area`);
        container.innerHTML = '';
        
        // Main Bracket
        rounds.forEach((roundMatches, roundIndex) => {
            const roundDiv = document.createElement('div');
            roundDiv.className = 'round';
            
            roundMatches.forEach((match, matchIndex) => {
                const matchDiv = document.createElement('div');
                matchDiv.className = 'match';
                
                // Determine names (if previous round winner exists, use that)
                // Logic: In rounds > 0, we need to look at previous round results
                // However, our data structure saves the state in 'rounds', so we just read from it.
                // But we need to ensure "TBD" names are updated if the data says so.
                // Actually, the click handler updates the DB, so we just render what's in DB.
                
                // Logic check: If it's not Round 0, update names based on previous round winners
                if (roundIndex > 0) {
                    const prevRound = rounds[roundIndex - 1];
                    const p1SourceMatch = prevRound[matchIndex * 2];
                    const p2SourceMatch = prevRound[matchIndex * 2 + 1];

                    // Update P1 info
                    if (p1SourceMatch.winner) {
                        const winnerObj = (p1SourceMatch.winner === p1SourceMatch.p1.id) ? p1SourceMatch.p1 : p1SourceMatch.p2;
                        match.p1 = winnerObj;
                    } else {
                         match.p1 = { name: "ç­‰å¾…ä¸­...", id: null };
                    }

                    // Update P2 info
                    if (p2SourceMatch.winner) {
                        const winnerObj = (p2SourceMatch.winner === p2SourceMatch.p1.id) ? p2SourceMatch.p1 : p2SourceMatch.p2;
                        match.p2 = winnerObj;
                    } else {
                        match.p2 = { name: "ç­‰å¾…ä¸­...", id: null };
                    }
                }

                // Render Players
                const p1Html = createPlayerHtml(match.p1, match.winner, category, roundIndex, matchIndex, 'p1');
                const p2Html = createPlayerHtml(match.p2, match.winner, category, roundIndex, matchIndex, 'p2');
                
                matchDiv.innerHTML = p1Html + `<div style='border-top:1px solid #eee; margin:2px 0;'></div>` + p2Html;
                roundDiv.appendChild(matchDiv);
            });
            
            container.appendChild(roundDiv);
        });

        // 3rd Place & Champion Logic
        const finalRoundIndex = rounds.length - 1;
        const finalMatch = rounds[finalRoundIndex][0];
        
        // 1. Champion Display
        const champDiv = document.getElementById(`${category}-champion`);
        if (finalMatch.winner && finalMatch.winner !== 'BYE') {
            const champion = (finalMatch.winner === finalMatch.p1.id) ? finalMatch.p1 : finalMatch.p2;
            const runnerUp = (finalMatch.winner === finalMatch.p1.id) ? finalMatch.p2 : finalMatch.p1;
            
            champDiv.style.display = 'block';
            champDiv.innerHTML = `<h3>ğŸ† å† è»ï¼š${champion.name}</h3><h4>ğŸ¥ˆ äºè»ï¼š${runnerUp.name}</h4>`;
        } else {
            champDiv.style.display = 'none';
        }

        // 2. 3rd Place Logic
        // Trigger: When Semi-Finals (Round N-1) are both done.
        if (rounds.length >= 2) {
            const semiRound = rounds[rounds.length - 2];
            const semi1 = semiRound[0];
            const semi2 = semiRound[1];

            if (semi1.winner && semi2.winner) {
                // Determine losers
                const loser1 = (semi1.winner === semi1.p1.id) ? semi1.p2 : semi1.p1;
                const loser2 = (semi2.winner === semi2.p1.id) ? semi2.p2 : semi2.p1;

                if (loser1.id !== 'BYE' && loser2.id !== 'BYE') {
                    // Update DB with 3rd place match players if not set
                    // Warning: Avoid infinite loop. Only update if data is different.
                    if ((!thirdPlaceData || thirdPlaceData.p1?.id !== loser1.id || thirdPlaceData.p2?.id !== loser2.id) && isAdmin) {
                         // We only auto-set players, not winner
                         // This is tricky in a render loop. Ideally, this should be done in the winHandler.
                         // But for simplicity, we check equality roughly.
                    }
                    
                    // Render 3rd Place Match
                    const thirdContainer = document.getElementById(`${category}-3rd-place`);
                    thirdContainer.style.display = 'block';
                    const thirdMatchDiv = document.getElementById(`${category}-3rd-match`);
                    
                    // Construct a fake match object for rendering
                    const p1 = loser1;
                    const p2 = loser2;
                    const winner = thirdPlaceData ? thirdPlaceData.winner : null;

                    const tp1Html = createPlayerHtml(p1, winner, category, 'third', 0, 'p1');
                    const tp2Html = createPlayerHtml(p2, winner, category, 'third', 0, 'p2');
                    
                    thirdMatchDiv.innerHTML = `<div class="match" style="width:200px;">${tp1Html}<div style='border-top:1px solid #eee; margin:2px 0;'></div>${tp2Html}</div>`;
                    
                    // Show 3rd/4th result if done
                    if (winner) {
                        const p3 = (winner === p1.id) ? p1.name : p2.name;
                        const p4 = (winner === p1.id) ? p2.name : p1.name;
                        champDiv.innerHTML += `<h4>ğŸ¥‰ å­£è»ï¼š${p3}</h4><h4>æ®¿è»ï¼š${p4}</h4>`;
                    }
                }
            }
        }
    }

    function createPlayerHtml(player, matchWinnerId, category, rIdx, mIdx, slot) {
        let classes = 'player';
        if (matchWinnerId) {
            if (matchWinnerId === player.id) classes += ' winner';
            else classes += ' loser';
        }
        
        let clickAction = '';
        let editAction = '';
        
        // Edit Name feature for Admin
        if (isAdmin && player.id && player.id !== 'BYE') {
             // We allow editing name in the bracket for quick fixes, though it doesn't sync back to user list, only bracket.
             // Simplification: Just show name.
        }

        // Set Winner Action
        // Allows clicking if: Admin mode OR (Friendly mode - anyone can click). 
        // User requested: "Opponent table can click win". Let's allow click to advance.
        if (player.id && player.id !== 'BYE' && !matchWinnerId) {
            clickAction = `onclick="setWinner('${category}', '${rIdx}', ${mIdx}, '${player.id}', '${slot}')"`;
        }

        return `<div class="${classes}" ${clickAction}>
                    <span>${player.name || '-'}</span>
                </div>`;
    }

    function setWinner(category, roundIdx, matchIdx, winnerId, slot) {
        if (!confirm(`ç¢ºèª ${winnerId === 'BYE' ? 'è¼ªç©º' : 'è©²é¸æ‰‹'} ç²å‹å—ï¼Ÿ`)) return;

        if (roundIdx === 'third') {
            // Handle 3rd place match
            db.ref(`tournament/${category}/thirdPlace`).update({
                winner: winnerId
            });
        } else {
            // Handle standard bracket
            roundIdx = parseInt(roundIdx);
            
            // 1. Update current match winner
            db.ref(`tournament/${category}/rounds/${roundIdx}/${matchIdx}`).update({
                winner: winnerId
            });

            // 2. Logic to handle "Next Round" population happens automatically in render 
            // BUT we should ideally check if it's the semi-final to populate 3rd place
            // Or if it's any round, ensure the next round exists.
            
            // Since our 'render' function calculates data dynamically based on previous rounds,
            // strictly speaking, we don't NEED to write to the next round in DB if we calculate it on the fly.
            // HOWEVER, my generate function created placeholders.
            // Let's rely on the render logic visually, but the DB structure is `rounds`.
            // The `rounds` array in DB is static. So when R0 finishes, R1 data in DB is still empty placeholders.
            // We need to validly push the winner to the next round in the DB to make it persistent and editable.
            
            // Fetch current state to update next round
            db.ref(`tournament/${category}`).once('value').then(snap => {
                const data = snap.val();
                const rounds = data.rounds;
                
                // If there is a next round
                if (roundIdx + 1 < rounds.length) {
                    const nextMatchIdx = Math.floor(matchIdx / 2);
                    const nextSlot = (matchIdx % 2 === 0) ? 'p1' : 'p2';
                    
                    // Find who won (object)
                    const currentMatch = rounds[roundIdx][matchIdx];
                    const winnerObj = (currentMatch.p1.id === winnerId) ? currentMatch.p1 : currentMatch.p2;

                    // Update next round
                    db.ref(`tournament/${category}/rounds/${roundIdx + 1}/${nextMatchIdx}/${nextSlot}`).set(winnerObj);
                } else {
                    // Final round finished
                    // Trigger refresh to show champion
                }

                // Special Check: Are we in Semi-Finals? (Round N-2)
                // rounds.length = Total rounds.
                // If rounds.length = 3 (8 people). R0=Q, R1=Semi, R2=Final.
                // If we just finished R1, populate 3rd place.
                if (roundIdx === rounds.length - 2) {
                     const currentMatch = rounds[roundIdx][matchIdx];
                     const loserObj = (currentMatch.p1.id === winnerId) ? currentMatch.p2 : currentMatch.p1;
                     
                     // Need to figure out if we are match 0 or 1 in semi-final to put in p1 or p2 of 3rd place
                     const thirdSlot = (matchIdx === 0) ? 'p1' : 'p2';
                     db.ref(`tournament/${category}/thirdPlace/${thirdSlot}`).set(loserObj);
                }
            });
        }
    }
</script>

</body>
</html>